name: Build & Deploy to Staging

on:
  workflow_dispatch:


env:
  ARTIFACT_NAME: StudioGhibliMM-dev
  ARTIFACT_PATH: build-artifact
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_CF_NAME_MAIN: MyCloudFormationStack
  AWS_CF_TEMPLATE_MAIN: cloudformation/templates/main.yml 
  DB_PASSWORD: ${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}



jobs:
  build:
    runs-on: ubuntu-latest
    environment: Staging
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # https://github.com/aws-actions/configure-aws-credentials
      - name: Set Up AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


      - name: Check for CloudFormation Changes
        run: |
          echo "Checking for CloudFormation changes..."
          CHANGESET=$(aws cloudformation create-change-set \
            --stack-name ${{ env.AWS_CF_NAME_MAIN }} \
            --template-body file://${{ env.AWS_CF_TEMPLATE_MAIN }} \
            --change-set-name TempChangeSet \
            --capabilities CAPABILITY_NAMED_IAM \
            --query "Id" --output text || echo "NO_CHANGES")

          echo "ChangeSet Result: $CHANGESET"

          if [ "$CHANGESET" = "NO_CHANGES" ]; then
            echo "No changes detected. Skipping deployment."
            echo "SKIP_DEPLOY=true" >> $GITHUB_ENV
            exit 0
          else
            echo "Changes detected. Proceeding with deployment."
            echo "SKIP_DEPLOY=false" >> $GITHUB_ENV
          fi
              
      # Deploy CloudFormation Stack
      - name: Deploy CloudFormation Main
        if: ${{ env.SKIP_DEPLOY }} != 'true'  # Only runs if no-skip is set
        uses: aws-actions/aws-cloudformation-github-deploy@v1.2.0
        with:
          name: ${{ env.AWS_CF_NAME_MAIN }}
          template: ${{ env.AWS_CF_TEMPLATE_MAIN }}
          capabilities: CAPABILITY_NAMED_IAM
          parameter-overrides: DBPassword=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}

      

  build-and-push-ecr:
    name: Build and Push Docker Image to ECR
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install Dependencies
        run: |
          sudo apt-get install -y jq
          pip install pyyaml

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      - name: Build Docker Image
        run: |
          docker build --platform=linux/amd64 -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/my-repo:latest .

      - name: Push Docker Image to ECR
        run: |
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/my-repo:latest

  deploy-task:
    name: Deploy ECS Service
    runs-on: ubuntu-latest
    needs: build-and-push-ecr
    steps:
      - name: Set Up AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install_Python
        run: | 
          sudo apt update
          sudo apt install python3

      - name: convert_yaml_to_json
        run: |
          python -c "import yaml, json, sys; print(json.dumps(yaml.safe_load(open('Task_def.yml'))))" > Task_def.json
      
      # Deploy Task Definition
      - name: Deploy Task Definition
        run: |
          aws ecs register-task-definition \
            --cli-input-json file://Task_def.json

      # Update ECS Service
      - name: Update ECS Service
        if: ${{ env.SKIP_DEPLOY }} == 'false'
        run: |
          echo "Registering new Task Definition revision..."
          TASK_DEFINITION_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://Task_def.json \
            --query "taskDefinition.taskDefinitionArn" --output text)

          echo "Updating ECS Service to use new Task Definition..."
          aws ecs update-service \
            --cluster MyClusterName \
            --service MyServiceName \
            --task-definition $TASK_DEFINITION_ARN \
            --force-new-deployment
