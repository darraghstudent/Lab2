name: Build & Deploy to Staging

on:
  workflow_dispatch:

env:
  ARTIFACT_NAME: StudioGhibliMM-dev
  ARTIFACT_PATH: build-artifact
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_ECS_CLUSTER_NAME: Mycluster
  AWS_ECS_SERVICE_NAME: Myservice
  AWS_CF_NAME_MAIN: MyCloudFormationStack
  AWS_CF_TEMPLATE_MAIN: cloudformation/templates/main.yml
  TASK_DEF_FILE: cloudformation/templates/Task_def.yml
  DB_PASSWORD: ${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}
  FlaskEnv: development2

jobs:
  build:
    runs-on: ubuntu-latest
    environment: Staging

    steps:
      - name: Set Environment Variables
        run: |
          echo "Setting environment variables for build job..."
          echo "TASK_DEF_FILE=cloudformation/templates/Task_def.yml" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}" >> $GITHUB_ENV
  
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set Up AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check for CloudFormation Changes
        run: |
          echo "Checking for CloudFormation changes..."
          CHANGESET=$(aws cloudformation create-change-set \
            --stack-name ${{ env.AWS_CF_NAME_MAIN }} \
            --template-body file://${{ env.AWS_CF_TEMPLATE_MAIN }} \
            --change-set-name TempChangeSet \
            --capabilities CAPABILITY_NAMED_IAM \
            --query "Id" --output text || echo "NO_CHANGES")
          echo "ChangeSet Result: $CHANGESET"
          if [ "$CHANGESET" = "NO_CHANGES" ]; then
            echo "No changes detected. Skipping deployment."
            echo "SKIP_DEPLOY=true" >> $GITHUB_ENV
          else
            echo "Changes detected. Proceeding with deployment."
            echo "SKIP_DEPLOY=false" >> $GITHUB_ENV
          fi

      - name: Deploy CloudFormation Main
        if: ${{ env.SKIP_DEPLOY != 'true' }}
        uses: aws-actions/aws-cloudformation-github-deploy@v1.2.0
        with:
          name: ${{ env.AWS_CF_NAME_MAIN }}
          template: ${{ env.AWS_CF_TEMPLATE_MAIN }}
          capabilities: CAPABILITY_NAMED_IAM
          parameter-overrides: DBPassword=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}

deploy-task:
  name: Deploy ECS Service
  runs-on: ubuntu-latest

  steps:
    - name: Checkout Repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Install jq
      run: sudo apt-get install -y jq

    - name: Set Up AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-region: ${{ secrets.AWS_REGION }}
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Debugging
      run: |
        echo "Current working directory: $(pwd)"
        echo "Listing files in directory:"
        if ! ls -l; then
          echo "Error: Failed to list files in the directory."
          exit 1
        fi

    - name: Validate Task_def.json File
      run: |
        if [ ! -f cloudformation/templates/Task_def.json ]; then
            echo "Error: cloudformation/templates/Task_def.json file not found!"
            exit 1
        fi

    - name: Fetch CloudFormation Export Values
      run: |
        echo "Fetching CloudFormation export values..."
        export TaskExecutionRoleArn=$(aws cloudformation list-exports --query "Exports[?Name=='TaskExecutionRoleArn'].Value" --output text)
        export MyTaskExecutionRoleExportName=$(aws cloudformation list-exports --query "Exports[?Name=='MyTaskExecutionRoleExportName'].Value" --output text)
        export ECRRepositoryURI=$(aws cloudformation list-exports --query "Exports[?Name=='ECRRepositoryURI'].Value" --output text)
        export RDSInstanceEndpoint=$(aws cloudformation list-exports --query "Exports[?Name=='RDSInstanceEndpoint'].Value" --output text)
        export AWS_REGION=$(aws cloudformation list-exports --query "Exports[?Name=='AWS_REGION'].Value" --output text)

        # Validate fetched values
        if [ -z "$TaskExecutionRoleArn" ] || [ -z "$MyTaskExecutionRoleExportName" ] || [ -z "$ECRRepositoryURI" ] || [ -z "$RDSInstanceEndpoint" ]; then
            echo "Error: Missing required export values!"
            exit 1
        fi

        echo "TaskExecutionRoleArn=$TaskExecutionRoleArn"
        echo "MyTaskExecutionRoleExportName=$MyTaskExecutionRoleExportName"
        echo "ECRRepositoryURI=$ECRRepositoryURI"
        echo "RDSInstanceEndpoint=$RDSInstanceEndpoint"
        echo "AWS_REGION=$AWS_REGION"

    - name: Inject Values into JSON
      run: |
        echo "Injecting values into JSON..."
        jq ".Resources.FlaskAppTaskDefinition.Properties.ExecutionRoleArn = \"$TaskExecutionRoleArn\" |
            .Resources.FlaskAppTaskDefinition.Properties.TaskRoleArn = \"$MyTaskExecutionRoleExportName\" |
            .Resources.FlaskAppTaskDefinition.Properties.ContainerDefinitions[0].Image = \"$ECRRepositoryURI\" |
            .Resources.FlaskAppTaskDefinition.Properties.ContainerDefinitions[0].Environment[2].Value = \"$DB_PASSWORD\" |
            .Resources.FlaskAppTaskDefinition.Properties.ContainerDefinitions[0].Environment[3].Value = \"$RDSInstanceEndpoint\" |
            .Resources.FlaskAppTaskDefinition.Properties.ContainerDefinitions[0].Environment[0].Value = \"$FlaskEnv\" |
            .Resources.FlaskAppTaskDefinition.Properties.ContainerDefinitions[0].LogConfiguration.Options.\"awslogs-region\" = \"$AWS_REGION\"" 
            cloudformation/templates/Task_def.json > Task_def_updated.json

        echo "Values injected successfully!"
        cat Task_def_updated.json

    - name: Register ECS Task Definition
      run: |
        echo "Registering ECS task definition..."
        aws ecs register-task-definition \
          --region ${{ secrets.AWS_REGION }} \
          --cli-input-json file://Task_def_updated.json

    - name: Update ECS Service
      run: |
        echo "Updating ECS Service..."
        TASK_DEFINITION_ARN=$(aws ecs describe-task-definition \
          --task-definition ${{ env.ARTIFACT_NAME }} \
          --query 'taskDefinition.taskDefinitionArn' --output text)
        aws ecs update-service \
          --cluster ${{ env.AWS_ECS_CLUSTER_NAME }} \
          --service ${{ env.AWS_ECS_SERVICE_NAME }} \
          --task-definition $TASK_DEFINITION_ARN
