name: Build & Deploy to Staging

on:
  workflow_dispatch:

env:
  ARTIFACT_NAME: StudioGhibliMM-dev
  ARTIFACT_PATH: build-artifact
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_ECS_CLUSTER_NAME: Mycluster
  AWS_ECS_SERVICE_NAME: Myservice
  AWS_CF_NAME_MAIN: MyCloudFormationStack
  AWS_CF_TEMPLATE_MAIN: cloudformation/templates/main.yml
  TASK_DEF_FILE: cloudformation/templates/Task_def.yml
  DB_PASSWORD: ${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}
  FlaskEnv: development2

jobs:
  build:
    runs-on: ubuntu-latest
    environment: Staging

    steps:
      - name: Set Environment Variables
        run: |
          echo "Setting environment variables for build job..."
          echo "TASK_DEF_FILE=cloudformation/templates/Task_def.yml" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}" >> $GITHUB_ENV
  
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set Up AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check if CloudFormation Stack Exists
        run: |
          echo "Checking if CloudFormation stack exists..."
      
          STACK_EXISTS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.AWS_CF_NAME_MAIN }} \
            --query "Stacks[0].StackStatus" \
            --output text || echo "STACK_NOT_FOUND")
      
          if [ "$STACK_EXISTS" = "STACK_NOT_FOUND" ]; then
            echo "Stack does not exist. Creating CloudFormation stack..."
            echo "CREATE_STACK=true" >> $GITHUB_ENV
          else
            echo "Stack exists. Proceeding with change set..."
            echo "CREATE_STACK=false" >> $GITHUB_ENV
          fi
      
      - name: Create CloudFormation Stack
        if: ${{ env.CREATE_STACK == 'true' }}
        run: |
          aws cloudformation create-stack \
            --stack-name ${{ env.AWS_CF_NAME_MAIN }} \
            --template-body file://${{ env.AWS_CF_TEMPLATE_MAIN }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameters ParameterKey=DBPassword,ParameterValue=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}
          echo "CloudFormation stack creation initiated."
      
      - name: Check for CloudFormation Changes
        if: ${{ env.CREATE_STACK == 'false' }}
        run: |
          echo "Checking for CloudFormation changes..."
          CHANGESET=$(aws cloudformation create-change-set \
            --stack-name ${{ env.AWS_CF_NAME_MAIN }} \
            --template-body file://${{ env.AWS_CF_TEMPLATE_MAIN }} \
            --change-set-name TempChangeSet \
            --capabilities CAPABILITY_NAMED_IAM \
            --query "Id" --output text || echo "NO_CHANGES")
          echo "ChangeSet Result: $CHANGESET"
          if [ "$CHANGESET" = "NO_CHANGES" ]; then
            echo "No changes detected. Skipping deployment."
            echo "SKIP_DEPLOY=true" >> $GITHUB_ENV
          else
            echo "Changes detected. Proceeding with deployment."
            echo "SKIP_DEPLOY=false" >> $GITHUB_ENV
          fi
      
      - name: Deploy CloudFormation Changes
        if: ${{ env.SKIP_DEPLOY != 'true' }}
        uses: aws-actions/aws-cloudformation-github-deploy@v1.2.0
        with:
          name: ${{ env.AWS_CF_NAME_MAIN }}
          template: ${{ env.AWS_CF_TEMPLATE_MAIN }}
          capabilities: CAPABILITY_NAMED_IAM
          parameter-overrides: DBPassword=${{ secrets.AWS_SECRET_DB_PASSWORD_DEV }}

  build-and-push-ecr:
    name: Build and Push Docker Image to ECR
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install Dependencies
        run: |
          sudo apt-get install -y jq
          pip install pyyaml

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      - name: Build Docker Image
        run: |
          docker build --platform=linux/amd64 -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/my-repo:latest .

      - name: Push Docker Image to ECR
        run: |
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/my-repo:latest


  deploy-Task_def:
    name: Deploy TasK Def Service
    needs: build-and-push-ecr
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Set Up AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Debug - List Directory Contents
        run: ls -R cloudformation/templates/


      - name: Validate Task_def.json File
        run: |
          if [ ! -f cloudformation/templates/Task_def.json ]; then
              echo "Error: cloudformation/templates/Task_def.json file not found!"
              exit 1
          fi
          
      - name: Test Write Permissions
        run: |
          echo "Testing write permissions..."
          echo "Test content" >> test_file.txt

          
      - name: Fetch CloudFormation Export Values
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Fetching CloudFormation export values..."
          
          # Fetch export values from CloudFormation
          MyTaskExecutionRoleExportName=$(aws cloudformation list-exports --query "Exports[?Name=='MyTaskExecutionRoleExportName'].Value" --output text)
          TaskExecutionRoleArn=$(aws cloudformation list-exports --query "Exports[?Name=='TaskExecutionRoleArn'].Value" --output text)
          ECRRepositoryURI=$(aws cloudformation list-exports --query "Exports[?Name=='ECRRepositoryURI'].Value" --output text)
          RDSInstanceEndpoint=$(aws cloudformation list-exports --query "Exports[?Name=='RDSInstanceEndpoint'].Value" --output text)
         


          # Replace placeholders in JSON file using jq
          jq \
            --arg TaskExecutionRoleArn "${TaskExecutionRoleArn}" \
            --arg MyTaskExecutionRoleExportName "${MyTaskExecutionRoleExportName}" \
            --arg ECRRepositoryURI "${ECRRepositoryURI}" \
            --arg RDSInstanceEndpoint "${RDSInstanceEndpoint}" \
            --arg AWS_REGION "${AWS_REGION}" \
            '.executionRoleArn = $TaskExecutionRoleArn |
             .taskRoleArn = $MyTaskExecutionRoleExportName |
             .containerDefinitions[0].image = $ECRRepositoryURI |
             .containerDefinitions[0].logConfiguration.options["awslogs-region"] = $AWS_REGION |
             .containerDefinitions[0].environment[3].value = $RDSInstanceEndpoint' \
            cloudformation/templates/Task_def.json > cloudformation/templates/Task_def_updated.json
      
          # Print updated JSON file to logs
          echo "Updated Task_def.json:"
          cat cloudformation/templates/Task_def_updated.json

          aws sts get-caller-identity
          
          # Export values to GitHub environment file
          echo "TaskExecutionRoleArn=${TaskExecutionRoleArn}" >> $GITHUB_ENV
          echo "MyTaskExecutionRoleExportName=${MyTaskExecutionRoleExportName}" >> $GITHUB_ENV
          echo "ECRRepositoryURI=${ECRRepositoryURI}" >> $GITHUB_ENV
          echo "RDSInstanceEndpoint=${RDSInstanceEndpoint}" >> $GITHUB_ENV
          echo "AWS_REGION=${AWS_REGION}" >> $GITHUB_ENV

          

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check for New Docker Image
        run: |
          echo "Checking for new Docker image in ECR..."
  
          # Retrieve latest image digest from ECR
          NEW_IMAGE_DIGEST=$(aws ecr describe-images \
            --repository-name my-repo \
            --query "imageDetails[?imageTags[0]=='latest'].imageDigest" \
            --output text)
          echo "New Image Digest: $NEW_IMAGE_DIGEST"
  
          # Retrieve current image digest from ECS task definition
          CURRENT_IMAGE_DIGEST=$(aws ecs describe-task-definition \
            --task-definition MyTaskDefinitionName \
            --query "taskDefinition.containerDefinitions[0].image" \
            --output text | cut -d '@' -f 2)
          echo "Current Image Digest: $CURRENT_IMAGE_DIGEST"
  
          # Compare digests
          if [ "$NEW_IMAGE_DIGEST" != "$CURRENT_IMAGE_DIGEST" ]; then
            echo "Image has changed. Proceeding with Task Definition update."
            echo "UPDATE_TASK_DEF=true" >> $GITHUB_ENV
          else
            echo "Image is the same. Skipping Task Definition update."
            echo "UPDATE_TASK_DEF=false" >> $GITHUB_ENV
          fi


      - name: Register ECS Task Definition
        if: ${{ env.UPDATE_TASK_DEF == 'true' }}
        run: |
          echo "Registering new task definition..."
          aws ecs register-task-definition \
            --cli-input-json file://cloudformation/templates/Task_def_updated.json


  deploy-ecs-service:
    name: Deploy ECS Service
    needs: deploy-Task_def
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout repository
      - name: Checkout Code
        uses: actions/checkout@v3

      # Step 2: Fetch CloudFormation Export Values
      - name: Fetch CloudFormation Export Values
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Fetching CloudFormation export values..."

          MySecurityGroup=$(aws cloudformation list-exports --query "Exports[?Name=='MySecurityGroup'].Value" --output text)
          PublicSubnetId=$(aws cloudformation list-exports --query "Exports[?Name=='PublicSubnetId'].Value" --output text)
          MyECSClusterName=$(aws cloudformation list-exports --query "Exports[?Name=='MyECSClusterName'].Value" --output text)
          FlaskAppTaskDefinition=$(aws cloudformation list-exports --query "Exports[?Name=='FlaskAppTaskDefinition'].Value" --output text)

          echo "Exported CloudFormation Values:"
          echo "MySecurityGroup=$MySecurityGroup"
          echo "PublicSubnetId=$PublicSubnetId"
          echo "MyECSClusterName=$MyECSClusterName"
          echo "FlaskAppTaskDefinition=$FlaskAppTaskDefinition"

          # Export variables for subsequent steps
          echo "MySecurityGroup=${MySecurityGroup}" >> $GITHUB_ENV
          echo "PublicSubnetId=${PublicSubnetId}" >> $GITHUB_ENV
          echo "MyECSClusterName=${MyECSClusterName}" >> $GITHUB_ENV
          echo "FlaskAppTaskDefinition=${FlaskAppTaskDefinition}" >> $GITHUB_ENV

      # Step 3: Deploy or Update ECS Service
      - name: Create or Update ECS Service
        if: ${{ env.UPDATE_TASK_DEF == 'true' }}
        run: |
          echo "Checking if ECS Service exists..."

          SERVICE_EXISTS=$(aws ecs describe-services \
            --cluster $MyECSClusterName \
            --services FlaskAppService  \
            --query "failures" --output text)

          if [ -z "$SERVICE_EXISTS" ]; then
            echo "Service exists. Updating ECS Service..."

            aws ecs update-service \
              --cluster $MyECSClusterName \
              --service FlaskAppService \
              --task-definition <TASK_DEFINITION_ARN> 

          else
            echo "Service does not exist. Creating ECS Service..."

            aws ecs create-service \
              --cluster $MyECSClusterName \
              --service-name FlaskAppService  \
              --task-definition <TASK_DEFINITION_ARN> \
              --desired-count 2 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$PublicSubnetId],securityGroups=[$MySecurityGroup],assignPublicIp='ENABLED'}"
          fi

